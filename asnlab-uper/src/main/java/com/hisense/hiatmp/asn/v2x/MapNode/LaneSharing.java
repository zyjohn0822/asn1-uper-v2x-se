/*
 * Generated by ASN.1 Java Compiler (https://www.asnlab.org/)
 * From ASN.1 module "MapLane"
 */
package com.hisense.hiatmp.asn.v2x.MapNode;

import org.asnlab.asndt.runtime.conv.AsnConverter;
import org.asnlab.asndt.runtime.conv.EncodingRules;
import org.asnlab.asndt.runtime.conv.ReflectionBitStringConverter;
import org.asnlab.asndt.runtime.type.AsnType;
import org.asnlab.asndt.runtime.value.BitString;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class LaneSharing extends BitString {

    public static final int overlappingLaneDescriptionProvided = 0;
    public static final int multipleLanesTreatedAsOneLane = 1;
    public static final int otherNonMotorizedTrafficTypes = 2;
    public static final int individualMotorizedVehicleTraffic = 3;
    public static final int busVehicleTraffic = 4;
    public static final int taxiVehicleTraffic = 5;
    public static final int pedestriansTraffic = 6;
    public static final int cyclistVehicleTraffic = 7;
    public static final int trackedVehicleTraffic = 8;
    public static final int pedestrianTraffic = 9;
    public final static AsnType TYPE = MapNode.type(393263);
    public final static AsnConverter CONV;

    static {
        CONV = new ReflectionBitStringConverter(LaneSharing.class);
    }

    public LaneSharing(byte[] bytes, byte unusedBits) {
        super(bytes, unusedBits);
    }

    public LaneSharing(int size) {
        super(size);
    }

    public LaneSharing() {
        super(0);
    }

    public static LaneSharing ber_decode(InputStream in) throws IOException {
        return (LaneSharing) TYPE.decode(in, EncodingRules.BASIC_ENCODING_RULES, CONV);
    }

    public static LaneSharing per_decode(boolean align, InputStream in) throws IOException {
        return (LaneSharing) TYPE.decode(in, align ? EncodingRules.ALIGNED_PACKED_ENCODING_RULES : EncodingRules.UNALIGNED_PACKED_ENCODING_RULES, CONV);
    }

    public boolean getOverlappingLaneDescriptionProvided() {
        return getBit(overlappingLaneDescriptionProvided);
    }

    public void setOverlappingLaneDescriptionProvided() {
        setBit(overlappingLaneDescriptionProvided, true);
    }

    public void clearOverlappingLaneDescriptionProvided() {
        setBit(overlappingLaneDescriptionProvided, false);
    }

    public boolean getMultipleLanesTreatedAsOneLane() {
        return getBit(multipleLanesTreatedAsOneLane);
    }

    public void setMultipleLanesTreatedAsOneLane() {
        setBit(multipleLanesTreatedAsOneLane, true);
    }

    public void clearMultipleLanesTreatedAsOneLane() {
        setBit(multipleLanesTreatedAsOneLane, false);
    }

    public boolean getOtherNonMotorizedTrafficTypes() {
        return getBit(otherNonMotorizedTrafficTypes);
    }

    public void setOtherNonMotorizedTrafficTypes() {
        setBit(otherNonMotorizedTrafficTypes, true);
    }

    public void clearOtherNonMotorizedTrafficTypes() {
        setBit(otherNonMotorizedTrafficTypes, false);
    }

    public boolean getIndividualMotorizedVehicleTraffic() {
        return getBit(individualMotorizedVehicleTraffic);
    }

    public void setIndividualMotorizedVehicleTraffic() {
        setBit(individualMotorizedVehicleTraffic, true);
    }

    public void clearIndividualMotorizedVehicleTraffic() {
        setBit(individualMotorizedVehicleTraffic, false);
    }

    public boolean getBusVehicleTraffic() {
        return getBit(busVehicleTraffic);
    }

    public void setBusVehicleTraffic() {
        setBit(busVehicleTraffic, true);
    }

    public void clearBusVehicleTraffic() {
        setBit(busVehicleTraffic, false);
    }

    public boolean getTaxiVehicleTraffic() {
        return getBit(taxiVehicleTraffic);
    }

    public void setTaxiVehicleTraffic() {
        setBit(taxiVehicleTraffic, true);
    }

    public void clearTaxiVehicleTraffic() {
        setBit(taxiVehicleTraffic, false);
    }

    public boolean getPedestriansTraffic() {
        return getBit(pedestriansTraffic);
    }

    public void setPedestriansTraffic() {
        setBit(pedestriansTraffic, true);
    }

    public void clearPedestriansTraffic() {
        setBit(pedestriansTraffic, false);
    }

    public boolean getCyclistVehicleTraffic() {
        return getBit(cyclistVehicleTraffic);
    }

    public void setCyclistVehicleTraffic() {
        setBit(cyclistVehicleTraffic, true);
    }

    public void clearCyclistVehicleTraffic() {
        setBit(cyclistVehicleTraffic, false);
    }

    public boolean getTrackedVehicleTraffic() {
        return getBit(trackedVehicleTraffic);
    }

    public void setTrackedVehicleTraffic() {
        setBit(trackedVehicleTraffic, true);
    }

    public void clearTrackedVehicleTraffic() {
        setBit(trackedVehicleTraffic, false);
    }

    public boolean getPedestrianTraffic() {
        return getBit(pedestrianTraffic);
    }

    public void setPedestrianTraffic() {
        setBit(pedestrianTraffic, true);
    }

    public void clearPedestrianTraffic() {
        setBit(pedestrianTraffic, false);
    }

    public boolean equals(Object obj) {
        if (!(obj instanceof LaneSharing)) {
            return false;
        }
        return TYPE.equals(this, obj, CONV);
    }

    public void ber_encode(OutputStream out) throws IOException {
        TYPE.encode(this, EncodingRules.BASIC_ENCODING_RULES, CONV, out);
    }

    public void per_encode(boolean align, OutputStream out) throws IOException {
        TYPE.encode(this, align ? EncodingRules.ALIGNED_PACKED_ENCODING_RULES : EncodingRules.UNALIGNED_PACKED_ENCODING_RULES, CONV, out);
    }


}
