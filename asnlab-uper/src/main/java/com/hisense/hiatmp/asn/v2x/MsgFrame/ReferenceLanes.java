/*
 * Generated by ASN.1 Java Compiler (https://www.asnlab.org/)
 * From ASN.1 module "RSI"
 */
package com.hisense.hiatmp.asn.v2x.MsgFrame;

import org.asnlab.asndt.runtime.conv.AsnConverter;
import org.asnlab.asndt.runtime.conv.EncodingRules;
import org.asnlab.asndt.runtime.conv.ReflectionBitStringConverter;
import org.asnlab.asndt.runtime.type.AsnType;
import org.asnlab.asndt.runtime.value.BitString;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class ReferenceLanes extends BitString {

    public static final int reserved = 0;
    public static final int lane1 = 1;
    public static final int lane2 = 2;
    public static final int lane3 = 3;
    public static final int lane4 = 4;
    public static final int lane5 = 5;
    public static final int lane6 = 6;
    public static final int lane7 = 7;
    public static final int lane8 = 8;
    public static final int lane9 = 9;
    public static final int lane10 = 10;
    public static final int lane11 = 11;
    public static final int lane12 = 12;
    public static final int lane13 = 13;
    public static final int lane14 = 14;
    public static final int lane15 = 15;
    public final static AsnType TYPE = MsgFrame.type(1507486);
    public final static AsnConverter CONV;

    static {
        CONV = new ReflectionBitStringConverter(ReferenceLanes.class);
    }

    public ReferenceLanes(byte[] bytes, byte unusedBits) {
        super(bytes, unusedBits);
    }

    public ReferenceLanes(int size) {
        super(size);
    }

    public ReferenceLanes() {
        super(0);
    }

    public static ReferenceLanes ber_decode(InputStream in) throws IOException {
        return (ReferenceLanes) TYPE.decode(in, EncodingRules.BASIC_ENCODING_RULES, CONV);
    }

    public static ReferenceLanes per_decode(boolean align, InputStream in) throws IOException {
        return (ReferenceLanes) TYPE.decode(in, align ? EncodingRules.ALIGNED_PACKED_ENCODING_RULES : EncodingRules.UNALIGNED_PACKED_ENCODING_RULES, CONV);
    }

    public boolean getReserved() {
        return getBit(reserved);
    }

    public void setReserved() {
        setBit(reserved, true);
    }

    public void clearReserved() {
        setBit(reserved, false);
    }

    public boolean getLane1() {
        return getBit(lane1);
    }

    public void setLane1() {
        setBit(lane1, true);
    }

    public void clearLane1() {
        setBit(lane1, false);
    }

    public boolean getLane2() {
        return getBit(lane2);
    }

    public void setLane2() {
        setBit(lane2, true);
    }

    public void clearLane2() {
        setBit(lane2, false);
    }

    public boolean getLane3() {
        return getBit(lane3);
    }

    public void setLane3() {
        setBit(lane3, true);
    }

    public void clearLane3() {
        setBit(lane3, false);
    }

    public boolean getLane4() {
        return getBit(lane4);
    }

    public void setLane4() {
        setBit(lane4, true);
    }

    public void clearLane4() {
        setBit(lane4, false);
    }

    public boolean getLane5() {
        return getBit(lane5);
    }

    public void setLane5() {
        setBit(lane5, true);
    }

    public void clearLane5() {
        setBit(lane5, false);
    }

    public boolean getLane6() {
        return getBit(lane6);
    }

    public void setLane6() {
        setBit(lane6, true);
    }

    public void clearLane6() {
        setBit(lane6, false);
    }

    public boolean getLane7() {
        return getBit(lane7);
    }

    public void setLane7() {
        setBit(lane7, true);
    }

    public void clearLane7() {
        setBit(lane7, false);
    }

    public boolean getLane8() {
        return getBit(lane8);
    }

    public void setLane8() {
        setBit(lane8, true);
    }

    public void clearLane8() {
        setBit(lane8, false);
    }

    public boolean getLane9() {
        return getBit(lane9);
    }

    public void setLane9() {
        setBit(lane9, true);
    }

    public void clearLane9() {
        setBit(lane9, false);
    }

    public boolean getLane10() {
        return getBit(lane10);
    }

    public void setLane10() {
        setBit(lane10, true);
    }

    public void clearLane10() {
        setBit(lane10, false);
    }

    public boolean getLane11() {
        return getBit(lane11);
    }

    public void setLane11() {
        setBit(lane11, true);
    }

    public void clearLane11() {
        setBit(lane11, false);
    }

    public boolean getLane12() {
        return getBit(lane12);
    }

    public void setLane12() {
        setBit(lane12, true);
    }

    public void clearLane12() {
        setBit(lane12, false);
    }

    public boolean getLane13() {
        return getBit(lane13);
    }

    public void setLane13() {
        setBit(lane13, true);
    }

    public void clearLane13() {
        setBit(lane13, false);
    }

    public boolean getLane14() {
        return getBit(lane14);
    }

    public void setLane14() {
        setBit(lane14, true);
    }

    public void clearLane14() {
        setBit(lane14, false);
    }

    public boolean getLane15() {
        return getBit(lane15);
    }

    public void setLane15() {
        setBit(lane15, true);
    }

    public void clearLane15() {
        setBit(lane15, false);
    }

    public boolean equals(Object obj) {
        if (!(obj instanceof ReferenceLanes)) {
            return false;
        }
        return TYPE.equals(this, obj, CONV);
    }

    public void ber_encode(OutputStream out) throws IOException {
        TYPE.encode(this, EncodingRules.BASIC_ENCODING_RULES, CONV, out);
    }

    public void per_encode(boolean align, OutputStream out) throws IOException {
        TYPE.encode(this, align ? EncodingRules.ALIGNED_PACKED_ENCODING_RULES : EncodingRules.UNALIGNED_PACKED_ENCODING_RULES, CONV, out);
    }


}
